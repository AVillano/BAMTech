<!--v003-->
# Stargate

## How To Access

Unfortunately, I have been struggling with CORS issues at multiple steps of this process. At this point, I am not sure if there is anything I can do other than own a domain to register the AWS EC2 instance to so that Chrome will stop blocking the requests that grab the data. If you are not using Chrome, I do not know how you can start up the browser without the web security. If you are using Chrome, you can properly access the site using the following steps:

1. Open a PowerShell window or terminal of choice
1. cd to the folder that your chrome.exe lives
    * For me, that would be > cd "C:\Program Files (x86)\Google\Chrome\Application"
1. Launch chrome.exe with the flags to turn off the additional web security
    * \> ./chrome.exe --user-data-dir="C://Chrome dev session" --disable-web-security
1. On the instance of Chrome that the previous step opened, go to the site
    * http://18.217.108.128

I am aware that this is not secure, among a few other things I did to get the app to this state, but thank you for your understanding.

## Thought Process

I apologize if there are any spelling or grammar errors here. I am writing this in a plain-text editor and a lot of it is just as a stream of consciousness to show my thoughts.

Of course I started by reading the directions and code. Sure, reading new code is great, but my personal preference to help myself understand it is to do a run-through of it. As a result, I will create a Postman collection of some of the HTTP requests I can expect the front end to make. 

Before even doing that, the first step is to create the SQLite db file, which was named according to StarbaseApiDatabase in appsettings.json. Being familiar with EF Core, the AddDbContext call in Program.cs told me exactly where to look next. I noticed there was a SeedData method from within the StargateContext, so I will uncomment that and apply the initial migration to get the database ready for use with the application. After doing so, the data in the SeedData method did not appear in the database, so I decided to create a new migration just to see if there was anything missing from the initial migration. The new migration file now added the data from SeedData but also altered CareerStartDate in AstronautDetail by making it not nullable. I will keep this new migration, but I do think there will be at least one more coming later for specifying more constraints on the data types, if I choose to do so here.

The next step will be to start trying to add test coverage to the backend because I believe that will help me 1. understand the code better and 2. help me look if anything needs fixing. 

Actually, I have changed my mind. Let me get the Angular project started and confirm I can connect with the backend. I am changing my focus for a couple reasons. First, my desktop does not have Angular installed so that could potentially bring its own set of issues to work through. Secondly, trying to connect the two can bring another set of issues that require working through, and I'd rather get these out of the way sooner rather than later. Well, I was correct on both fronts. The installation of Angular was not smooth, although it was not a great effort to get working. Connecting the two apps, on the other hand, took a lot longer to resolve. I first ran into a CORS error, which is always a fun one to see. I tried a few things to get around that, and while that error seemed to disappear, I was now getting another error. I spent some time trying to debug that, and then for fun, I decided to undo the changes I made to get around the CORS error. This time, after seemingly just reverting the changes, the CORS error did not return. Ah, the joys of programming. After digging into it, I saw self-signed certs mentioned a couple times, so that brought me back to the Program.cs file. In an attempt to increase my amount of bad things to do so I actually have something to present, I decided to comment out UseHttpsRedirection and see if that worked, and yes, it did. I am fully aware this does not leave a good impression, but again, I really want to actually have something to show instead of spending a bunch of time more accurately solving these types of errors, given my very limited time. I also messaged my previous coworker, as in the person who with I rewrote the frontend at my previous position, and he also had no recollection of us running into these type of issues. I'm not sure if this was a newer thing or not. I saw Angular 17 has server-side rendering and now uses standalone components, which are two features that were definitely not present when I did this at my previous position, so maybe that is part of the issue. What is more likely, though, is that something was already set up on my work laptop or there was some configuration that made me not run into this error. I plan to look into it more after submitting this project. At this point, I have a very basic Angular application that calls the backend and gets some data.

Now that I have that working, I will go back now to looking at testing the backend. I will make use of Postman for this part and then turn that into unit tests on the api. I will take a look at having an in-memory database for the tests. Let's start by looking at the API and making sure all the functionality is in place. The first expectation is that it can "retrieve a person by name." Let me actually do this a little bit out of order since we want data to already exist to try to get. I will instead skip to the third expectation, which is that it can "add/update a person by name." As it is, we are able to create a Person just fine with a POST to "/person," but there is not a way to update a person currently. The appropriate thing to do here, in my opinion, is to add a PUT route to "/person/{name}" that has a body with the new name like with the POST to "/person." I will do that shortly, but before I do, I want to try to POST the same name multiple times and see how that goes. Well that fails. Let's take a look at CreatePerson. I see CreatePersonPreProcessor and the logic in Process looks like it should be preventing this from happening, but debugging shows that this logic is not being called. I have never heard of MediatR before, but a quick search suggests looking at registration in the Program file, which shows that a different preprocessor is being registered, but not this one. I am just going to add a registration for the CreatePersonPreProcessor and see if it then gets called. Great, that preprocess logic is now being called and properly throwing an exception about the bad request and then ends up returning a 500. We could talk semantics about why this is not the ideal code to return, but I'll leave that as it is for now(I think a 409 would make more sense in this case). Now that the create is taken care of, I will take a look at the update. The PUT request is now complete and appears to work properly. I still really find it weird to use a name here instead of an id, such as the external id I like to use, which I should have mentioned before by now. Upon initial checks, retrieving a person by name and retrieving all people appears to be functioning as intended with no changes. Since we again need data to first be present before trying to query it, I will look at adding an AstronautDuty next. The first thing that I saw in the request handler is that I believe the CareerEndDate calculation was incorrect when astronautDetail is null. Also, I am a bit embarrassed that it me this long to notice, but I see now this is following CQRS, using EF Core for providing the object model and writes and then Dapper for the reads. The next thing I am seeing is that it seems this would not work properly if data was not sent in the order of DutyStartDate ASC. For example, if there was some historical data being added. Testing this was done with two Postman calls to the POST endpoint: the first one having a DutyStartDate set to current day and the second having DutyStartDate a year earlier. As we can see, this does not seem to work properly and there are a few things that are wrong. Firstly, the entry with the DutyStartDate of a year ago does not have a DutyEndDate. Secondly, the entry with the DutyStartState of the current day now has a DutyEndDate of a year before that, which obviously makes no sense. It cannot end before it starts. Thirdly, the AstronautDetail has a CareerStartDate of current day, but the earliest DutyStartDate from these duties is actually a year before that. My ideal solution is to allow historical data to be sent in, but that does complicate it a little. As is, there would need to be a good amount of logic that would need to be added. Alternatively, we could allow the CreateAstronautDuty object to also take in a DutyEndDate, but that still would require more logic and checks to verify all the data is correct after each POST. I see that there is a verifyNoPreviousDuty variable in the preprocessor, but I'm not entirely sure what that is trying to do. The logic is just checking if the database has an AstronautDuty with the incoming request's DutyTitle and DutyStartDate. I thought that maybe it was checking against duplicates for the same Person, but the query does not take the Person into account. Is this maybe supposed to be doing part of the logic that I was mentioning? To check that there is no duty that has a DutyStartDate after the incoming one? I will ask about that, but for now I have decided that I will be doing nothing. Another thing worth noting that I should have mentioned before, is that as it stands, Name values are case-sensitive. Whether or not this is a problem depends on the consistency of the data coming from the external service. Next up is retrieving an AstronautDuty by name. This endpoint currently just calls GetPersonByName, so that will need some changes. It appears that the code is already there and it only needs to be properly called(GetAstronautDutiesByName). Actually, it does appear there is no preprocessor in that file, so I am going to go and add one to keep it consistent. In it, we will check that are Person with the supplied Name exists, the same way I did it for the Person PUT request. I take that back. The queries do not appear to have preprocessing, so I will leave it as is. If a NullReferenceException gets hit, which is easily possible, the try catch will already return a 500. I once again take part of that back. Doing that returns a null reference exception message in the response, which we definitely do not want to do. I will throw a BadRequestException if the Person is null. This prevents the system from exposing too much.

Next we should be examining the rules and comparing it to the current backend logic. The first rule is that "a Person is uniquely identified by their Name." That is currently not implemented and the way I would implement that is to put an index on that field and make it unique. Why put an index on that field? Well, it's the column we are going to be doing a lot of our queries against. Note that this could be over-optimization at this point. Additionally, at this time I still have concerns about using Name this way and am awaiting a response to my email that asked a question on the topic. The second rule of "a Person who has not had an astronaut assignment will not have Astronaut records" does not seem to be a problem. I don't know how this end would verify that. They can only be added through CreateAstronautDuty. Likewise, the third and fourth rule appear to already be in effect. After making the small change previously, as mentioned in the above paragraph, the fifth rule should be good. I'm not entirely sure what the sixth rule of "a Person is classified as 'Retired' when a Duty Title is 'RETIRED'" means. Do we have to change the objects in any way beyond what already is done as part of the logic of adding a new AstronautDuty? Do we not want to show "Retired" people on the frontend? I will ask about this. The seventh rule is that "a Person's Career End Date is one day before the Retired Duty Start Date." My mistake, this was the one that I made the small change for. 

Now that it's the weekend and I do have some plans, I am going to change my priorities a bit. Since this is essentially a "given requirements, give me something by [deadline]" test, I have decided the next thing to do would be to make the UI display data and then think I will give deploying it a shot. I know that there is a lot to deploying something properly and I have no experience with AWS, but let's see how it goes. What that does mean, however, is I am going to skip automated testing for the time being. Why? Well, I have seen that automated testing tends to be the first thing to go when time is short. It definitely is not a good practice, but that is not my focus here. My main goal is to end with something presentable, and at least I will be mentioning all these things. Another thing that I will not be doing for the sake time that is important is adding authentication and authorization of some sort. For example, I am going with the assumption that the backend should only accept POST and PUT requests from the known external service. There are things that need to be done in order to apply that rule. As for the frontend, I am assuming that not all the data is supposed to be visible to everyone. For example, maybe some people are not supposed to be visible to people below a certain clearance, or maybe some users shouldn't be able to get into the system at all. That would be handled by authenticating with an identity provider of some sort, but I will not be covering that here either.

Before attempting to deploy, I am going to make my frontend a bit more presentable. The first thing to note is that I am not going to implement pagination, but it is definitely something you would want to do. The main page was in a spot that I was happy with, so I then moved on to making a modal for displaying duties for a given person. The CORS issues are back, but at least this time now I actually have a little bit of understanding why it does and does not work sometimes. Since the first subscription for the main page is immediate, I believe it is actually being processed before being pushed to the client as part of server-side rendering. This is somewhat confirmed by if I put a button the same page that calls the same subscription again when clicked, I get a CORS error. I tried to start up Chrome in such a way that it would ignore this, but it is not doing so. As a result, I am just going to preload the data that we need. Of course, I would not do this in a production environment but I don't want to be wrestling with this for who knows how long, given the limited time frame. At this point, the preloading works and I have a very basic modal that shows/hides on clicking a person and closes on click the close button. Next is to display it properly in the center and on top of the rest of the page. One thing I want to mention is that yes the frontend should absolutely have a search bar, pagination, and sorting. I have decided not to implement that because due to the aforementioned CORS issue, I wouldn't even be able to test it since it would make another fetch to the backend for data.

With that in a good state, I am now going to look back at some of the previous things I was thinking about and other things I was awaiting a response as I have since received a response. The first thing I have been thinking about again is who do we actually want to display? As per the directions, "ACTS is used as a tool to maintain a record of all the People that have served as Astronauts." Given that, I would not want people that have not served as astronauts to be displayed in the webpage, but where should that be handled? We can simply apply the same logic to the API and say that GetPeople and GetPersonByName should only return people that have served as an astronaut. At the same time, do I really like that solution? I'm not really sure. That could cause a situation where the external service makes a GET to grab a list of people currently in the system, then ties to make a POST to create someone that is actually in the system but did not appear in the results of the GET, but then gets an error because that person already exists. Now, the POST could instead return a 409 instead of a 500 in that given case, which would be at least a bit better, in my opinion. Or as mentioned earlier, maybe different user roles as part of authentication would get different data. I have decided to leave it as is for now, but I think it's worth mentioning. I will, however, be using a little bit of color to mark active, retired, and non-astronauts in the webpage. Next, I looked at the logic in CreateAstronautDuty again, specifically verifyNoPreviousDuty. I decided to merge that into two checks, at least one I which I hope is what it was going for. The first one is that the incoming duty is not a duplicate for a person and the second is that the incoming duty is not older than another for a person. I do want to reiterate, however, that I do think we should allow historical data to come in, as in a duty that already existed but was not entered in the system, but again it would require some extra checks and overlap verifications, which I am not going to implement at this time. The next thing I did was check back because I thought some SQL injection was possible, and this time I found it. I created a table called "test" for this purpose and then created a user named "test_name' = Name; DROP TABLE test;" with the POST request to PersonController. All that was left was to make a call to CreateAstronautDuty with that name and then the table was deleted. I looked at the Dapper documentation parameters and applied them to the CreateAstronautDuty code. Now, there is something to be said that I can create a Person with the name of "test_name' = Name; DROP TABLE test;" but that is a different story. What I have done in the past is follow the rules as set out by what I am communicating with. For example, my previous work would communicate externally with the IRS, so their rules for names are what we applied. Note that EF Core automatically does this parameterization for us, so we only have to worry about queries with Dapper. After that, I look at what being retired means. To my knowledge, people keep their previous rank after being retired and can also come out of retirement. As per the email response regarding retirement, someone that is retired cannot have a current duty. I have changed what I display on the frontend to reflect that. Active astronauts will display rank, current duty, and career start date, non-astronauts will display as so, and retired astronauts will display their rank, career start date, and career end date. Since it was a quick thing to add and I do think it's a good practice, I went back and added a CreatedAt and UpdatedAt column to the tables. Part of this included making an abstract Entity class that they extend and then making a new migration. On the topic of data, there really should be more constraints on the data by specifying specific columns types and sizes, but that's a whole design discussion that I do not have the chance to have at this time, so I will not be doing anything about it.

I am pretty happy with the way things look now. Next up is to build the Angular project and serve it as part of the .NET project, dockerize, and then deploy. I know I said before that I would not be doing that, but I think I have changed my mind. 

Since it has been another night that I have been able to sleep on it, I have been thinking a lot about what the frontend should be able to do. I still think that a Person should not be able to be edited because then we still have the problem that the external service would not know about that, unless there is some two-way contract, which I think I would advise against. This means that if they try to send the same Person but with an outdated name, it thinks they are new. Now, I have been thinking that maybe it would be acceptable to allow new AstronautDuties to be created from the UI, but that again has to do with the contract and actual specifications of what we want the product we are building to do, which is not something a single developer should make the calls on given that someone is asking for this to be built. Regardless, I am not going to add that functionality to the page because of the CORS issues, which would prevent it from even working and being testable at this time. In any case, since this is essentially a quick proof-of-concept, I would be able to take the feedback and make changes accordingly.

Alright, now back to working on getting this thing deployed. I am in the testing connectivity phase of the two Docker containers and of course, I had to run out of disc space. I'm so close that I really hope I can get this working before having to purge my hard drive. I now have two Docker containers that are able to communicate with one another. While I wait for my AWS account to be fully registered, let's look at some of the bad practices I've done. Firstly, you may have noticed that I said I currently have two Docker containers. This definitely should be doable with one, so why am I doing two? I am quite sure I should be able to run ng build and connect the static files to the api so that running the api automatically serves the static files, but there are two reasons I stopped trying to do that. The files and structure of what ng build generated looks different than what I am familiar with, which I think is part of the newer SSR, and it that because Microsoft has been pushing Blazor, documentation on hosting these static files lacking. Instead, I have a frontend image and backend image. Another point on the frontend image is that I am having it run ng serve. This is also a bad practice and as ng serve explicitly tells you, that server is meant to be for development only. As for the backend image, the database should not be setup the way it currently is, as in a file in the image. This means that any changes to the database will not be persisted should the container go down. What I should be doing is create the database in the virtual machine that the container will be running on, and mount it as a volume in Docker. All that means is tell Docker that there is an external resource that we want to use and persist across containers. I am not familiar with that as I have only used hosted databases when deploying in the past, so I am doing it this way for the demo in the interest of time. One last note for both of them is that I should be making use of environment variables and not hard coding connection strings.

The application is now deployed on an EC2 instance. I was messing around with things and going back and forth on them, but the final deployment is as follows: the api is running on an AWS EC2 instance through a Docker container, and the frontend was built into static files, moved to the same EC2 instance, and is being hosted with nginx.*

I went back and put some extremely basic logging that just outputs when requests come in. Ideally I would want more logging and also put them into JSON format, but that is for another time. JSON formatted logs make them easily consumable by log aggregators and visualizers like Kibana, but I no longer want to mess with the EC2 instance since it is in a working state. 

As mentioned, there are some parts that are lacking due to the time constraint. Below, I am going to list some functionality that is lacking:
* There are no rules to what names can come in when creating a Person
    * I can create a Person with no name
    * I can create a Person with an extremely long name
    * I can create a Person with a name consisting of any character
* AstronautDuties are a bit limited
    * I think end dates should be able to be set without requiring a new AstronautDuty to be created
        * As mentioned previously, this is good for accepting historical data
        * Is someone not able to go on leave without retiring?
* Delete routes
    * I think unless some rule requires keeping the data, people should, and sometimes by law have to, be able to request their data to be deleted

## My Notes

The below section will cover things that I think are important to do in an actual production environment that I will not be doing for the sake of this take-home.
Alternatively, it may mention things that I decided to do to keep it simple but would not do in reality.

* ~~Ideally, the frontend and backend of this project would be put into separate Docker containers~~
    * This makes both codebases easily portable should anything change regarding the environment we want to deploy to
* ~~On the topic of deployment, I will not be deploying this~~
    * There are many options to choose from, including AWS's EC2 or something like DigitalOcean's Droplets(I've used these before), for VMs that Docker containers could be deployed to
    * Of course, there is also Kubernetes, but that is overkill for something like this and overkill for a lot of smaller projects in general
    * And on top of that, there are GitHub CI/CD tools, which I have not used before so I am not sure if I will take advantange of that, but in production you would want to
* I have chosen to go with SQLite for my database simple because it is easy and lightweight, and contrary to what many say, it can be used just fine in a production environment
    * Yes, I have committed the database file to the repo
    * No, I would not do that normally, but in this case it makes it easier for people to pull and see considering this is a technical test
    * Oh and the code is already calling UseSqlite, which I saw after making my decision
* Things I tend to like to add to my data types that are not currently present
    * External ids: This provides a unique identifier that can be used outside of the backend and does not expose the actual id; very useful with the frontend and api requests
        * This doesn't matter too much here becuase we are using Name, which is not exposing an id anyway, but I don't really like using Name this way either
    * ~~CreatedAt/UpdatedAt: I think these are self-explanatory~~

***

## Astronaut Career Tracking System (ACTS)

ACTS is used as a tool to maintain a record of all the People that have served as Astronauts. When serving as an Astronaut, your *Job* (Duty) is tracked by your Rank, Title and the Start and End Dates of the Duty.

The People that exist in this system are not all Astronauts. ACTS maintains a master list of People and Duties that are updated from an external service (not controlled by ACTS). The update schedule is determined by the external service.

## Definitions

1. A person's astronaut assignment is the Astronaut Duty.
1. A person's current astronaut information is stored in the Astronaut Detail table.
1. A person's list of astronaut assignments is stored in the Astronaut Duty table.

## Requirements

##### Enhance the Stargate API (Required)

The REST API is expected to do the following:

1. Retrieve a person by name.
1. Retrieve all people.
1. Add/update a person by name.
1. Retrieve Astronaut Duty by name.
1. Add an Astronaut Duty.

##### Implement a user interface: (Required)

The UI is expected to do the following:

1. Successfully run an Angular web application that demonstrates production level quality.
1. Implement call(s) to retrieve an individual's astronaut duties.
1. Display the progress of the process and the results in a visually sophisticated and appealing manner.

## Tasks

Overview
Examine the code, find and resolve any flaws, if any exist. Identify design patterns and follow or change them. Provide fix(es) and be prepared to describe the changes.

1. Generate the database
   * This is your source and storage location
1. Enforce the rules
1. Improve defensive coding
1. Add unit tests
   * identify the most impactful methods requiring tests
   * reach >50% code coverage
1. Implement process logging
   * Log exceptions
   * Log successes
   * Store the logs in the database

## Rules

1. A Person is uniquely identified by their Name.
1. A Person who has not had an astronaut assignment will not have Astronaut records.
1. A Person will only ever hold one current Astronaut Duty Title, Start Date, and Rank at a time.
1. A Person's Current Duty will not have a Duty End Date.
1. A Person's Previous Duty End Date is set to the day before the New Astronaut Duty Start Date when a new Astronaut Duty is received for a Person.
1. A Person is classified as 'Retired' when a Duty Title is 'RETIRED'.
1. A Person's Career End Date is one day before the Retired Duty Start Date.